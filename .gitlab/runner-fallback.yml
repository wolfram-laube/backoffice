# =============================================================================
# RUNNER FALLBACK SYSTEM v3
# =============================================================================
# Smart runner selection with GCP auto-start capability.
#
# Priority:
#   1. Local runners (mac#1, mac#2, yoga) - Tag: local-shell
#   2. GCP runners (Nordic) - Tag: gcp-shell
#   3. Any self-hosted docker runner - Tag: docker-any
#
# All jobs use docker-any (self-hosted) to avoid GitLab SaaS CI quota limits.
# The system checks runner availability and starts GCP if needed.
# =============================================================================

variables:
  # Runner tag priorities
  LOCAL_RUNNER_TAG: "local-shell"
  GCP_RUNNER_TAG: "gcp-shell"
  FALLBACK_RUNNER_TAG: "docker-any"
  
  # GCP VM Configuration
  GCP_PROJECT: "myk8sproject-207017"
  GCP_ZONE: "europe-north2-a"
  GCP_INSTANCE: "gitlab-runner-nordic"
  GCP_STARTUP_TIMEOUT: "180"
  
  # Default runner (used if no check runs)
  RUNNER_TAG: "gcp-shell"

# -----------------------------------------------------------------------------
# RUNNER CHECK: Intelligent runner selection
# -----------------------------------------------------------------------------
.runner-check-base:
  stage: .pre
  image: alpine:latest
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  before_script:
    - apk add --no-cache curl jq > /dev/null 2>&1

runner-check:
  extends: .runner-check-base
  script:
    - |
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "  RUNNER AVAILABILITY CHECK"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      API_URL="${CI_API_V4_URL}/groups/${CI_PROJECT_NAMESPACE_ID}/runners"
      
      # Check local runners first (preferred)
      echo ""
      echo "1ï¸âƒ£ Checking local runners (${LOCAL_RUNNER_TAG})..."
      LOCAL_COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
        "${API_URL}?tag_list=${LOCAL_RUNNER_TAG}&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
      echo "   Found: ${LOCAL_COUNT} online"
      
      if [ "${LOCAL_COUNT}" -gt 0 ]; then
        echo "   âœ… Using local runner"
        echo "RUNNER_TAG=${LOCAL_RUNNER_TAG}" >> runner.env
        echo "RUNNER_SOURCE=local" >> runner.env
        echo "GCP_START_NEEDED=false" >> runner.env
        cat runner.env
        exit 0
      fi
      
      # Check GCP runners
      echo ""
      echo "2ï¸âƒ£ Checking GCP runners (${GCP_RUNNER_TAG})..."
      GCP_COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
        "${API_URL}?tag_list=${GCP_RUNNER_TAG}&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
      echo "   Found: ${GCP_COUNT} online"
      
      if [ "${GCP_COUNT}" -gt 0 ]; then
        echo "   âœ… Using GCP runner (already online)"
        echo "RUNNER_TAG=${GCP_RUNNER_TAG}" >> runner.env
        echo "RUNNER_SOURCE=gcp-existing" >> runner.env
        echo "GCP_START_NEEDED=false" >> runner.env
        cat runner.env
        exit 0
      fi
      
      # No runners available - need to start GCP
      echo ""
      echo "3ï¸âƒ£ No runners available!"
      echo "   ðŸš€ Will start GCP VM..."
      echo "RUNNER_TAG=${GCP_RUNNER_TAG}" >> runner.env
      echo "RUNNER_SOURCE=gcp-started" >> runner.env
      echo "GCP_START_NEEDED=true" >> runner.env
      cat runner.env
  artifacts:
    reports:
      dotenv: runner.env
    expire_in: 1 hour
  rules:
    - if: $SKIP_RUNNER_CHECK == "true"
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "api"
    - if: $CI_PIPELINE_SOURCE == "trigger"
    - if: $CI_PIPELINE_SOURCE == "web"
    - when: manual
      allow_failure: true

# -----------------------------------------------------------------------------
# GCP VM AUTO-START (if needed)
# -----------------------------------------------------------------------------
gcp-auto-start:
  stage: .pre
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  needs:
    - job: runner-check
      artifacts: true
  variables:
    GIT_STRATEGY: none
  script:
    - |
      if [ "${GCP_START_NEEDED}" != "true" ]; then
        echo "GCP start not needed (source: ${RUNNER_SOURCE})"
        exit 0
      fi
      
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "  STARTING GCP VM: ${GCP_INSTANCE}"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      # Authenticate with service account
      if [ -z "${GCP_SERVICE_ACCOUNT_KEY}" ]; then
        echo "âŒ GCP_SERVICE_ACCOUNT_KEY not set!"
        exit 1
      fi
      
      echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
      gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
      gcloud config set project ${GCP_PROJECT}
      
      # Check current VM status
      echo ""
      echo "Checking VM status..."
      STATUS=$(gcloud compute instances describe ${GCP_INSTANCE} \
        --zone=${GCP_ZONE} --format='value(status)' 2>/dev/null || echo "NOT_FOUND")
      echo "Current status: ${STATUS}"
      
      case "${STATUS}" in
        RUNNING)
          echo "âœ… VM already running, waiting for runner..."
          ;;
        TERMINATED|STOPPED)
          echo "Starting VM..."
          gcloud compute instances start ${GCP_INSTANCE} --zone=${GCP_ZONE}
          echo "Waiting 30s for boot..."
          sleep 30
          ;;
        *)
          echo "âŒ Unexpected status: ${STATUS}"
          exit 1
          ;;
      esac
      
      # Wait for runner to come online
      echo ""
      echo "Waiting for runner to register..."
      TIMEOUT=${GCP_STARTUP_TIMEOUT}
      API_URL="${CI_API_V4_URL}/groups/${CI_PROJECT_NAMESPACE_ID}/runners"
      
      while [ ${TIMEOUT} -gt 0 ]; do
        GCP_COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
          "${API_URL}?tag_list=${GCP_RUNNER_TAG}&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
        
        if [ "${GCP_COUNT}" -gt 0 ]; then
          echo "âœ… GCP runner is online!"
          exit 0
        fi
        
        echo "  Waiting... (${TIMEOUT}s remaining)"
        sleep 15
        TIMEOUT=$((TIMEOUT - 15))
      done
      
      echo "âŒ Timeout waiting for GCP runner!"
      exit 1
  rules:
    - if: $GCP_START_NEEDED == "true"
    - when: never

# -----------------------------------------------------------------------------
# GCP VM AUTO-STOP (cleanup after pipeline)
# -----------------------------------------------------------------------------
gcp-auto-stop:
  stage: .post
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - |
      # Only stop if we started it
      if [ "${RUNNER_SOURCE}" != "gcp-started" ]; then
        echo "GCP was not started by this pipeline, keeping running"
        exit 0
      fi
      
      # Check if auto-stop is enabled
      if [ "${GCP_AUTO_STOP}" != "true" ]; then
        echo "GCP_AUTO_STOP not enabled, keeping running"
        echo "Set GCP_AUTO_STOP=true to auto-stop after pipeline"
        exit 0
      fi
      
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "  STOPPING GCP VM: ${GCP_INSTANCE}"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
      gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
      gcloud config set project ${GCP_PROJECT}
      
      gcloud compute instances stop ${GCP_INSTANCE} --zone=${GCP_ZONE}
      echo "âœ… GCP VM stopped (saving costs)"
  rules:
    - if: $GCP_AUTO_STOP == "true"
      when: always
    - when: never
  allow_failure: true

# -----------------------------------------------------------------------------
# MANUAL VM CONTROLS
# -----------------------------------------------------------------------------
gcp-vm-start:
  stage: deploy
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project ${GCP_PROJECT}
    - echo "Starting ${GCP_INSTANCE}..."
    - gcloud compute instances start ${GCP_INSTANCE} --zone=${GCP_ZONE}
    - sleep 10
    - gcloud compute instances describe ${GCP_INSTANCE} --zone=${GCP_ZONE} --format="table(name,status,networkInterfaces[0].accessConfigs[0].natIP)"
    - echo "âœ… VM started"
  rules:
    - when: manual
  allow_failure: true

gcp-vm-stop:
  stage: deploy
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project ${GCP_PROJECT}
    - echo "Stopping ${GCP_INSTANCE}..."
    - gcloud compute instances stop ${GCP_INSTANCE} --zone=${GCP_ZONE}
    - echo "âœ… VM stopped"
  rules:
    - when: manual
  allow_failure: true

gcp-vm-status:
  stage: deploy
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project ${GCP_PROJECT}
    - echo "â”â”â” GCP VM Status â”â”â”"
    - gcloud compute instances describe ${GCP_INSTANCE} --zone=${GCP_ZONE} --format="table(name,status,machineType.basename(),networkInterfaces[0].accessConfigs[0].natIP)"
  rules:
    - when: manual
  allow_failure: true

# -----------------------------------------------------------------------------
# RUNNER STATUS: Debug all runners
# -----------------------------------------------------------------------------
runner-status:
  extends: .runner-check-base
  script:
    - |
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "  ALL RUNNER STATUS"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      API_URL="${CI_API_V4_URL}/groups/${CI_PROJECT_NAMESPACE_ID}/runners"
      
      echo ""
      echo "=== Own Runners (non-SaaS) ==="
      curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
        "${API_URL}?per_page=100" 2>/dev/null | jq -r '
        .[] | select(.description | test("saas|gitlab.com|runners-manager") | not) |
        "\(if .online then "ðŸŸ¢" else "ðŸ”´" end) \(.description) [\(.tag_list | join(", "))]"
      ' 2>/dev/null || echo "  (keine oder Fehler)"
      
      echo ""
      echo "=== By Tag ==="
      for TAG in local-shell gcp-shell gcp-docker shell docker; do
        COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
          "${API_URL}?tag_list=${TAG}&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "?")
        echo "  ${TAG}: ${COUNT} online"
      done
  rules:
    - when: manual
  allow_failure: true
