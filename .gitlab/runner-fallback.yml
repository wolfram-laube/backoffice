# =============================================================================
# RUNNER AVAILABILITY & FALLBACK SYSTEM v4
# =============================================================================
# Ensures at least one runner is available before jobs execute.
# Does NOT select runners ‚Äî that's MAB/NSAI's job.
#
# Architecture:
#   runner-fallback  ‚Üí AVAILABILITY: "Is anyone alive?"
#   mab-integration  ‚Üí SELECTION:    "Who's best?"
#   nsai/            ‚Üí REASONING:    "Why that one?"
#
# Runner Fleet (2026-02):
#   Tag            Runners                          Executor
#   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#   docker-any     Nordic, Mac, Mac2, Linux Yoga     Docker
#   shell-any      Nordic, Mac, Mac2, Linux Yoga     Shell
#   k8s-any        Nordic*, Mac, Mac2, Linux Yoga    K8s
#   any-runner     All 11 runners                    Any
#
#   * Nordic K8s currently offline (k3s not running)
#
# Tag Hierarchy:
#   any-runner ‚äÉ {docker-any, shell-any, k8s-any}
#   docker-any ‚äÉ {mac-docker, mac2-docker, linux-docker, nordic}
#   shell-any  ‚äÉ {mac-group-shell, mac2-shell, linux-shell, nordic}
#   k8s-any    ‚äÉ {mac-k8s, mac2-k8s, linux-k8s, gcp-k8s}
#
# Fallback Flow:
#   1. Are docker-any runners online? ‚Üí Done
#   2. No? ‚Üí Is Nordic GCP VM running? ‚Üí Start it
#   3. Wait for runner to register
#
# =============================================================================

variables:
  # Runner tag for availability check (must match actual runner tags)
  AVAILABILITY_TAG: "docker-any"

  # GCP VM Configuration (last-resort fallback)
  GCP_PROJECT: "myk8sproject-207017"
  GCP_ZONE: "europe-north2-a"
  GCP_INSTANCE: "gitlab-runner-nordic"
  GCP_STARTUP_TIMEOUT: "180"

# -----------------------------------------------------------------------------
# AVAILABILITY CHECK: Are any runners online?
# -----------------------------------------------------------------------------
# This job itself runs on docker-any. If it can run, at least one runner
# is alive ‚Äî which may be sufficient. The deeper check validates that
# MULTIPLE runners are available for MAB balancing.
# -----------------------------------------------------------------------------
runner-check:
  stage: .pre
  image: alpine:latest
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  before_script:
    - apk add --no-cache curl jq > /dev/null 2>&1
  script:
    - |
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "  RUNNER FLEET AVAILABILITY"
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

      API_URL="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/runners"

      echo ""
      echo "üìä Checking runner availability by executor type..."
      echo ""

      TOTAL_ONLINE=0
      for TAG in docker-any shell-any k8s-any; do
        COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
          "${API_URL}?tag_list=${TAG}&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
        TOTAL_ONLINE=$((TOTAL_ONLINE + COUNT))

        if [ "${COUNT}" -gt 0 ]; then
          echo "  ‚úÖ ${TAG}: ${COUNT} online"
          curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
            "${API_URL}?tag_list=${TAG}&status=online" 2>/dev/null | \
            jq -r '.[] | "     üü¢ \(.description)"' 2>/dev/null || true
        else
          echo "  ‚ùå ${TAG}: 0 online"
        fi
      done

      echo ""
      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      # Check specifically for docker-any (most jobs need this)
      DOCKER_COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
        "${API_URL}?tag_list=docker-any&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")

      if [ "${DOCKER_COUNT}" -ge 2 ]; then
        echo "‚úÖ Fleet healthy: ${DOCKER_COUNT} docker runners online (MAB can balance)"
        echo "FLEET_STATUS=healthy" >> runner.env
        echo "DOCKER_RUNNERS=${DOCKER_COUNT}" >> runner.env
        echo "GCP_START_NEEDED=false" >> runner.env
      elif [ "${DOCKER_COUNT}" -eq 1 ]; then
        echo "‚ö†Ô∏è  Fleet degraded: only 1 docker runner (no balancing possible)"
        echo "FLEET_STATUS=degraded" >> runner.env
        echo "DOCKER_RUNNERS=1" >> runner.env
        echo "GCP_START_NEEDED=false" >> runner.env
      else
        echo "üö® Fleet down: 0 docker runners!"
        echo "FLEET_STATUS=down" >> runner.env
        echo "DOCKER_RUNNERS=0" >> runner.env
        echo "GCP_START_NEEDED=true" >> runner.env
      fi

      cat runner.env
  artifacts:
    reports:
      dotenv: runner.env
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /\[skip ci\]/
      when: never
    - if: $SKIP_RUNNER_CHECK == "true"
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "api"
    - if: $CI_PIPELINE_SOURCE == "trigger"
    - if: $CI_PIPELINE_SOURCE == "web"
    - when: manual
      allow_failure: true

# -----------------------------------------------------------------------------
# GCP VM AUTO-START (only when fleet is down)
# -----------------------------------------------------------------------------
gcp-auto-start:
  stage: .pre
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  needs:
    - job: runner-check
      artifacts: true
  variables:
    GIT_STRATEGY: none
  script:
    - |
      if [ "${GCP_START_NEEDED}" != "true" ]; then
        echo "Fleet status: ${FLEET_STATUS} ‚Äî GCP start not needed"
        exit 0
      fi

      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "  STARTING GCP VM: ${GCP_INSTANCE}"
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

      if [ -z "${GCP_SERVICE_ACCOUNT_KEY}" ]; then
        echo "‚ùå GCP_SERVICE_ACCOUNT_KEY not set!"
        exit 1
      fi

      echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
      gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
      gcloud config set project ${GCP_PROJECT}

      STATUS=$(gcloud compute instances describe ${GCP_INSTANCE} \
        --zone=${GCP_ZONE} --format='value(status)' 2>/dev/null || echo "NOT_FOUND")
      echo "Current VM status: ${STATUS}"

      case "${STATUS}" in
        RUNNING)
          echo "VM already running, waiting for runner to register..."
          ;;
        TERMINATED|STOPPED)
          echo "Starting VM..."
          gcloud compute instances start ${GCP_INSTANCE} --zone=${GCP_ZONE}
          echo "Waiting 30s for boot..."
          sleep 30
          ;;
        *)
          echo "‚ùå Unexpected status: ${STATUS}"
          exit 1
          ;;
      esac

      # Wait for runner to come online
      echo ""
      echo "Waiting for Nordic runner to register..."
      TIMEOUT=${GCP_STARTUP_TIMEOUT}
      API_URL="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/runners"

      while [ ${TIMEOUT} -gt 0 ]; do
        COUNT=$(curl -sf --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
          "${API_URL}?tag_list=nordic&status=online" 2>/dev/null | jq 'length' 2>/dev/null || echo "0")

        if [ "${COUNT}" -gt 0 ]; then
          echo "‚úÖ Nordic runner is online!"
          exit 0
        fi

        echo "  Waiting... (${TIMEOUT}s remaining)"
        sleep 15
        TIMEOUT=$((TIMEOUT - 15))
      done

      echo "‚ùå Timeout waiting for Nordic runner!"
      exit 1
  rules:
    - if: $GCP_START_NEEDED == "true"
    - when: never

# -----------------------------------------------------------------------------
# GCP VM AUTO-STOP (cost savings)
# -----------------------------------------------------------------------------
gcp-auto-stop:
  stage: .post
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - |
      if [ "${GCP_AUTO_STOP}" != "true" ]; then
        echo "GCP_AUTO_STOP not enabled, keeping VM running"
        exit 0
      fi

      echo "Stopping GCP VM: ${GCP_INSTANCE}..."
      echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
      gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
      gcloud config set project ${GCP_PROJECT}
      gcloud compute instances stop ${GCP_INSTANCE} --zone=${GCP_ZONE}
      echo "‚úÖ VM stopped (saving costs)"
  rules:
    - if: $GCP_AUTO_STOP == "true"
      when: always
    - when: never
  allow_failure: true

# -----------------------------------------------------------------------------
# MANUAL VM CONTROLS
# -----------------------------------------------------------------------------
gcp-vm-start:
  stage: deploy
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project ${GCP_PROJECT}
    - echo "Starting ${GCP_INSTANCE}..."
    - gcloud compute instances start ${GCP_INSTANCE} --zone=${GCP_ZONE}
    - sleep 10
    - gcloud compute instances describe ${GCP_INSTANCE} --zone=${GCP_ZONE} --format="table(name,status,networkInterfaces[0].accessConfigs[0].natIP)"
    - echo "‚úÖ VM started"
  rules:
    - when: manual
  allow_failure: true

gcp-vm-stop:
  stage: deploy
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project ${GCP_PROJECT}
    - echo "Stopping ${GCP_INSTANCE}..."
    - gcloud compute instances stop ${GCP_INSTANCE} --zone=${GCP_ZONE}
    - echo "‚úÖ VM stopped"
  rules:
    - when: manual
  allow_failure: true

gcp-vm-status:
  stage: deploy
  image: google/cloud-sdk:slim
  tags:
    - docker-any
  variables:
    GIT_STRATEGY: none
  script:
    - echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /tmp/gcp-key.json
    - gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
    - gcloud config set project ${GCP_PROJECT}
    - echo "‚îÅ‚îÅ‚îÅ GCP VM Status ‚îÅ‚îÅ‚îÅ"
    - gcloud compute instances describe ${GCP_INSTANCE} --zone=${GCP_ZONE} --format="table(name,status,machineType.basename(),networkInterfaces[0].accessConfigs[0].natIP)"
  rules:
    - when: manual
  allow_failure: true
