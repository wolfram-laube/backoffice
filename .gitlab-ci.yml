stages:
  - lint
  - test
  - build
  - deploy

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LINTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

lint:flake8:
  stage: lint
  script:
    - pip install flake8 -q --break-system-packages 2>/dev/null || pip install flake8 -q
    - flake8 modules/ --max-line-length=120 --ignore=E501,W503 || true
  allow_failure: true

lint:black:
  stage: lint
  script:
    - pip install black -q --break-system-packages 2>/dev/null || pip install black -q
    - black --check modules/ || true
  allow_failure: true

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TESTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

test:syntax:
  stage: test
  script:
    - python3 -m py_compile modules/**/*.py || find modules -name "*.py" -exec python3 -m py_compile {} \;

test:imports:
  stage: test
  script:
    - python3 -c "from modules.applications import ApplicationService" || true
    - python3 -c "from modules.invoicing import InvoiceService" || true

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BUILD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

build:wheel:
  stage: build
  script:
    - pip install build -q --break-system-packages 2>/dev/null || pip install build -q
    - python3 -m build --wheel 2>/dev/null || echo "No pyproject.toml yet"
  artifacts:
    paths:
      - dist/*.whl
    expire_in: 7 days
  allow_failure: true

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INVOICE GENERATION (triggered by timesheet changes)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

invoice:generate:
  stage: build
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - timesheets/**/*.yaml
        - timesheets/**/*.yml
  before_script:
    - pip install pyyaml --break-system-packages -q 2>/dev/null || pip install pyyaml -q
    - |
      if ! command -v typst &> /dev/null; then
        echo "Installing Typst..."
        curl -L -o /tmp/typst.tar.xz https://github.com/typst/typst/releases/download/v0.12.0/typst-x86_64-unknown-linux-musl.tar.xz 2>/dev/null
        cd /tmp && tar -xf typst.tar.xz
        mkdir -p $HOME/bin
        mv typst-x86_64-unknown-linux-musl/typst $HOME/bin/
        export PATH="$HOME/bin:$PATH"
      fi
      typst --version || echo "Typst not available on this runner"
  script:
    - export PATH="$HOME/bin:$PATH"
    - mkdir -p invoices
    - python3 scripts/generate-invoices.py || echo "Invoice generation skipped"
  artifacts:
    paths:
      - invoices/*.pdf
    expire_in: 90 days
  allow_failure: true

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# K8S INFRASTRUCTURE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Einmaliges Setup - manuell triggern
k8s:setup-gcp:
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
    - if: $CI_COMMIT_MESSAGE =~ /\[k8s-setup\]/
  variables:
    GCP_VM: "gitlab-runner"
    GCP_ZONE: "europe-west3-a"
    GCP_PROJECT: "myk8sproject-207017"
  before_script:
    - |
      echo "$GCP_SA_KEY" > /tmp/sa-key.json
      gcloud auth activate-service-account --key-file=/tmp/sa-key.json
      gcloud config set project $GCP_PROJECT
  script:
    - |
      echo "â˜¸ï¸ K8s Setup auf GCP"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      
      # 1. VM starten falls nicht running
      VM_STATUS=$(gcloud compute instances describe $GCP_VM --zone=$GCP_ZONE --format='get(status)' 2>/dev/null || echo "UNKNOWN")
      if [ "$VM_STATUS" != "RUNNING" ]; then
        echo "ğŸš€ Starte GCP VM..."
        gcloud compute instances start $GCP_VM --zone=$GCP_ZONE --quiet
        sleep 60
      fi
      
      EXTERNAL_IP=$(gcloud compute instances describe $GCP_VM --zone=$GCP_ZONE --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
      echo "ğŸŒ IP: $EXTERNAL_IP"
      
      # 2. k3s installieren (idempotent)
      echo "â˜¸ï¸ k3s Setup..."
      gcloud compute ssh $GCP_VM --zone=$GCP_ZONE --quiet --command="
        if ! command -v k3s &> /dev/null; then
          echo 'Installing k3s...'
          curl -sfL https://get.k3s.io | sh -s - \
            --write-kubeconfig-mode 644 \
            --disable traefik \
            --disable servicelb \
            --tls-san $EXTERNAL_IP
          sleep 15
          mkdir -p ~/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
          sudo chown \$(id -u):\$(id -g) ~/.kube/config
          
          # Ingress-Nginx
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/baremetal/deploy.yaml
          kubectl create namespace blauweiss --dry-run=client -o yaml | kubectl apply -f -
        else
          echo 'k3s already installed'
        fi
        kubectl get nodes
      "
      
      # 3. GitLab Secret erstellen
      echo "ğŸ”‘ GitLab Secret..."
      gcloud compute ssh $GCP_VM --zone=$GCP_ZONE --quiet --command="
        kubectl create secret generic gitlab-credentials \
          --namespace=blauweiss \
          --from-literal=GITLAB_TOKEN='$GITLAB_TOKEN' \
          --from-literal=GITLAB_PROJECT_ID='$CI_PROJECT_ID' \
          --dry-run=client -o yaml | kubectl apply -f -
      "
      
      # 4. Manifests deployen
      echo "ğŸš€ Deploy Manifests..."
      gcloud compute ssh $GCP_VM --zone=$GCP_ZONE --quiet --command="
        kubectl apply -f https://gitlab.com/wolfram_laube/blauweiss_llc/freelancer-admin/-/raw/main/infra/k8s/00-namespace.yaml
        kubectl apply -f https://gitlab.com/wolfram_laube/blauweiss_llc/freelancer-admin/-/raw/main/infra/k8s/02-configmap-frontend.yaml
        kubectl apply -f https://gitlab.com/wolfram_laube/blauweiss_llc/freelancer-admin/-/raw/main/infra/k8s/10-timesheet-api.yaml
        kubectl apply -f https://gitlab.com/wolfram_laube/blauweiss_llc/freelancer-admin/-/raw/main/infra/k8s/11-timesheet-frontend.yaml
        kubectl apply -f https://gitlab.com/wolfram_laube/blauweiss_llc/freelancer-admin/-/raw/main/infra/k8s/20-ingress.yaml
        
        echo ''
        echo 'ğŸ“¦ Pods:'
        kubectl get pods -n blauweiss
        echo ''
        echo 'ğŸŒ Services:'
        kubectl get svc -n blauweiss
      "
      
      echo ""
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "âœ… K8s Setup Complete!"
      echo "ğŸŒ Portal: http://$EXTERNAL_IP:30080"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Auto-Deploy bei Manifest-Ã„nderungen
k8s:deploy:
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - infra/k8s/**/*
        - portal/frontend/**/*
  script:
    - |
      echo "ğŸš€ K8s Deploy (Manifest Update)"
      
      # GCP Auth
      echo "$GCP_SA_KEY" > /tmp/sa-key.json
      gcloud auth activate-service-account --key-file=/tmp/sa-key.json
      
      # Deploy auf GCP k3s
      gcloud compute ssh gitlab-runner --zone=europe-west3-a --quiet --command="
        kubectl apply -f https://gitlab.com/wolfram_laube/blauweiss_llc/freelancer-admin/-/raw/main/infra/k8s/ --recursive 2>/dev/null || true
        kubectl rollout restart deployment -n blauweiss 2>/dev/null || true
        kubectl get pods -n blauweiss
      " || echo "GCP deploy skipped (VM might be off)"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAGES (Timesheet App + Documentation)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pages:
  stage: deploy
  script:
    - mkdir -p public
    - cp public/timesheet.html public/index.html 2>/dev/null || echo "<h1>Freelancer Admin</h1>" > public/index.html
  artifacts:
    paths:
      - public
  only:
    - main


# Quick deploy job mit korrektem Auth

# Simpler deploy - keine Shell-Escaping Probleme

# Smart deploy - erkennt ob Mac oder GCP
k8s:smart-deploy:
  stage: deploy
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /\[k8s-deploy\]/
  script:
    - |
      echo "ğŸ” Erkenne Runner..."
      HOSTNAME=$(hostname)
      echo "   Hostname: $HOSTNAME"
      
      if [[ "$HOSTNAME" == "gitlab-runner" ]]; then
        echo "â˜ï¸ LÃ¤uft auf GCP - direkt deployen"
        export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
        
        kubectl apply -f infra/k8s/all-in-one.yaml
        
        kubectl create secret generic gitlab-credentials \
          --namespace=blauweiss \
          --from-literal=GITLAB_TOKEN="$GITLAB_TOKEN" \
          --from-literal=GITLAB_PROJECT_ID="77555895" \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo ""
        echo "ğŸ“¦ Pods:"
        kubectl get pods -n blauweiss -o wide
        echo ""
        echo "ğŸŒ Services:"
        kubectl get svc -n blauweiss
        
        # IP ausgeben
        EXTERNAL_IP=$(curl -s ifconfig.me)
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "âœ… Portal: http://$EXTERNAL_IP:30080"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
      else
        echo "ğŸ LÃ¤uft auf Mac - SSH zu GCP"
        echo "$GCP_SA_KEY" > /tmp/sa-key.json
        gcloud auth activate-service-account --key-file=/tmp/sa-key.json
        
        cat infra/k8s/all-in-one.yaml | gcloud compute ssh gitlab-runner --zone=europe-west3-a --quiet --command="
          export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
          cat > /tmp/manifests.yaml
          kubectl apply -f /tmp/manifests.yaml
          kubectl create secret generic gitlab-credentials --namespace=blauweiss --from-literal=GITLAB_TOKEN='$GITLAB_TOKEN' --from-literal=GITLAB_PROJECT_ID='77555895' --dry-run=client -o yaml | kubectl apply -f -
          echo ''
          kubectl get pods -n blauweiss
          kubectl get svc -n blauweiss
        "
      fi

k8s:fix-ingress:
  stage: deploy
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /\[fix-ingress\]/
  script:
    - |
      export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
      
      echo "ğŸŒ Installing Ingress-Nginx..."
      kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/baremetal/deploy.yaml
      
      echo "â³ Waiting for Ingress Controller..."
      sleep 30
      
      echo "ğŸ”§ Patching NodePort to 30080..."
      kubectl patch svc ingress-nginx-controller -n ingress-nginx --type=json \
        -p='[{"op": "replace", "path": "/spec/ports/0/nodePort", "value": 30080}]' || true
      
      echo ""
      echo "ğŸ“‹ Ingress-Nginx Status:"
      kubectl get pods -n ingress-nginx
      kubectl get svc -n ingress-nginx
      
      echo ""
      echo "ğŸ“¦ Blauweiss Pods:"
      kubectl get pods -n blauweiss
      
      EXTERNAL_IP=$(curl -s ifconfig.me)
      echo ""
      echo "âœ… Portal: http://$EXTERNAL_IP:30080"

k8s:open-port:
  stage: deploy
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /\[open-port\]/
  script:
    - |
      echo "ğŸ”“ Opening port 30080..."
      
      # GCP Firewall via gcloud (falls Rechte vorhanden)
      gcloud compute firewall-rules create allow-k8s-portal \
        --allow tcp:30080,tcp:80,tcp:443 \
        --source-ranges=0.0.0.0/0 \
        --description="K8s Portal" \
        --project=myk8sproject-207017 2>/dev/null || echo "Firewall rule exists or no permission"
      
      # Alternative: Check ob Port erreichbar
      EXTERNAL_IP=$(curl -s ifconfig.me)
      echo "ğŸŒ External IP: $EXTERNAL_IP"
      
      # Local test
      echo "ğŸ§ª Local test..."
      curl -s --connect-timeout 5 http://localhost:30080 | head -5 || echo "Port 30080 not responding locally"
      
      # Ingress-Nginx NodePort checken
      export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
      echo ""
      echo "ğŸ“‹ Ingress-Nginx Service:"
      kubectl get svc -n ingress-nginx ingress-nginx-controller -o wide
      
      echo ""
      echo "ğŸŒ Try: http://$EXTERNAL_IP:30080"
